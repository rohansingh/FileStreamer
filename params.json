{"tagline":"Use FileStreamer when you need to work on sequential slices of a file with the HTML5 File API.","google":"UA-17515286-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"FileStreamer","body":"FileStreamer\r\n============\r\n\r\nUse `FileStreamer` when you need to work on sequential slices of a file with the\r\n[HTML5 File API](http://www.w3.org/TR/FileAPI/). By working on slices, you can\r\nwork on a large file without loading the entire file into memory at once.\r\n\r\nExample\r\n-------\r\nHere is a contrived example of calculating the length of a file:\r\n\r\n    var someFile = document.getElementById('fileInput').files[0];\r\n\r\n    var fileLength = 0;\r\n    var myWorkFunc = function (event, eof) {\r\n      binaryString = event.target.result;\r\n      fileLength += binaryString.length;\r\n\r\n      if (eof) {\r\n        alert('The length of this file in bytes is: ' + fileLength);\r\n      }\r\n    }\r\n\r\n    var fs = new FileStreamer(4 * 1024 * 1024);\r\n    fs.streamAsBinaryString(someFile, myWorkFunc);\r\n\r\nThis is a contrived example since you could just use `someFile.size`, but it\r\ndemonstrates the basic usage.\r\n\r\nUsage\r\n-----\r\nTo construct a `FileStreamer`, specify the desired slice size in bytes. For\r\nexample:\r\n\r\n    var fs = new FileStreamer(4 * 1024 * 1024); // 4MB slice size\r\n\r\nSince the File API is relatively new and implementations vary across\r\nbrowsers, I can't tell you what slice size to use. Large slice sizes will\r\nneed more memory, while smaller slice sizes will use more CPU.\r\n\r\n### Stream functions\r\nThe available stream functions correspond to each of the read functions in\r\nthe [FileReader API](https://developer.mozilla.org/en/DOM/FileReader). Each\r\nfunction accepts the same arguments as its corresponding `FileReader` function,\r\nwith the addition of a callback.\r\n\r\n  - `streamAsArrayBuffer(file, callback)`\r\n  - `streamAsBinaryString(file, callback)`\r\n  - `streamAsDataURL(file, callback)`\r\n  - `streamAsText(file, encoding, callback)`\r\n\r\n### Work function\r\nThe work function (callback) receives two arguments:\r\n\r\n  1. `event`: the `ProgressEvent` from `FileReader.onloadend`.\r\n  2. `eof`: `true` if this is the last slice in the file, otherwise `false`.\r\n\r\nThe callback is guaranteed to be called sequentially for each file slice. If\r\nthe callback returns `false`, streaming will stop. Otherwise, streaming will\r\ncontinue to the next slice.\r\n\r\n### Using FileReaderSync\r\nBy default, `FileStreamer` uses a [FileReader](https://developer.mozilla.org/en/DOM/FileReader)\r\nunder the covers. In some cases, you may want to use a [FileReaderSync](https://developer.mozilla.org/en/DOM/FileReaderSync)\r\ninstead. To do this, pass `true` for the second argument to the constructor:\r\n\r\n    var fs = new FileStreamer(4 * 1024 * 1024, true);\r\n\r\nWhen using a `FileReaderSync`, your work function will receive these arguments:\r\n\r\n  1. `result`: the data read from the `FileReaderSync`.\r\n  2. `eof`: same as with normal usage.\r\n\r\nNone of the other API's change. Though a `FileReaderSync` will be used under the\r\ncovers, `FileStreamer` itself will not become synchronous; you must still supply\r\na callback.\r\n\r\nThe usual use case for this is when using `FileStreamer` in a [web worker](https://developer.mozilla.org/En/Using_web_workers).\r\nAs of Firefox 9, the `FileReaderSync` interface is available to a web worker,\r\nbut the `FileReader` is not.\r\n\r\n"}